import pygame

# -----------------------------
# CONFIG / CONSTANTS
# -----------------------------
WIDTH, HEIGHT = 1280, 720
FPS = 60

BOTTOM_FRACTION = 1 / 4  # bottom quarter is castle
ENEMY_SIZE = 40
BASE_ENEMY_SPEED = 120


# -----------------------------
# ENEMY CLASS
# -----------------------------
class Enemy:
    def __init__(self, x, y, speed):
        self.pos = pygame.Vector2(x, y)
        self.speed = speed
        self.state = "moving"  # "moving" or "attacking"

    def get_rect(self):
        rect = pygame.Rect(0, 0, ENEMY_SIZE, ENEMY_SIZE)
        rect.center = self.pos
        return rect

    def update(self, dt, castle_rect):
        """Update enemy movement and collision with castle."""
        if self.state == "moving":
            # move down
            self.pos.y += self.speed * dt

            rect = self.get_rect()
            if rect.colliderect(castle_rect):
                self.state = "attacking"
                # snap to top of castle
                self.pos.y = castle_rect.top - ENEMY_SIZE / 2

    def draw(self, surface):
        rect = self.get_rect()
        if self.state == "attacking":
            color = (50, 200, 50)  # green
        else:
            color = (200, 50, 50)  # red
        pygame.draw.rect(surface, color, rect)


# -----------------------------
# GAME CLASS
# -----------------------------
class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("CastleDefend0r")

        self.clock = pygame.time.Clock()
        self.running = True

        self.font = pygame.font.SysFont(None, 24)
        self.slot_labels = ["slot_1", "slot_2", "slot_3", "slot_4", "slot_5"]

        # wave / enemies
        self.enemies: list[Enemy] = []
        self.wave_number = 0

        # castle hp
        self.castle_max_hp = 100.0
        self.castle_hp = self.castle_max_hp

        # dps per attacking enemy
        self.castle_damage_per_second_per_enemy = 5.0

    # ---------- RECT HELPERS ----------
    def get_spawn_rect(self):
        spawn_width = WIDTH - 100
        spawn_height = 80
        x = (WIDTH - spawn_width) // 2
        y = 0
        return pygame.Rect(x, y, spawn_width, spawn_height)

    def get_castle_rect(self):
        bottom_height = int(HEIGHT * BOTTOM_FRACTION)
        top_height = HEIGHT - bottom_height
        return pygame.Rect(0, top_height, WIDTH, bottom_height)

    def get_wave_button_rect(self):
        castle_rect = self.get_castle_rect()
        button_width = 220
        button_height = 50
        x = WIDTH - button_width - 20
        y = castle_rect.top + 20
        return pygame.Rect(x, y, button_width, button_height)

    # ---------- WAVES ----------
    def spawn_wave(self):
        self.wave_number += 1
        spawn_rect = self.get_spawn_rect()

        num_enemies = 3 + self.wave_number * 2
        speed_base = BASE_ENEMY_SPEED + self.wave_number * 10

        for i in range(num_enemies):
            x = spawn_rect.left + (i + 0.5) * (spawn_rect.width / num_enemies)
            y = spawn_rect.bottom + ENEMY_SIZE / 2
            enemy = Enemy(x, y, speed_base)
            self.enemies.append(enemy)

    # ---------- MAIN LOOP ----------
    def run(self):
        while self.running:
            dt = self.clock.tick(FPS) / 1000.0
            self.handle_events()
            self.update(dt)
            self.draw()
        pygame.quit()

    # ---------- EVENTS ----------
    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False
                if event.key == pygame.K_SPACE:
                    self.spawn_wave()

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                mouse_pos = event.pos
                if self.get_wave_button_rect().collidepoint(mouse_pos):
                    self.spawn_wave()

    # ---------- UPDATE ----------
    def update(self, dt):
        castle_rect = self.get_castle_rect()

        # update enemies and calc dmg
        damage_this_frame = 0.0
        for enemy in self.enemies:
            enemy.update(dt, castle_rect)

            if enemy.state == "attacking" and self.castle_hp > 0:
                damage_this_frame += self.castle_damage_per_second_per_enemy * dt

        # apply dmg
        if damage_this_frame > 0:
            self.castle_hp = max(0.0, self.castle_hp - damage_this_frame)

        # later: remove dead enemies

    # ---------- DRAW ----------
    def draw(self):
        self.draw_background(self.screen)
        self.draw_spawn_area(self.screen)
        self.draw_slots(self.screen, self.font, self.slot_labels)

        castle_rect = self.get_castle_rect()
        pygame.draw.rect(self.screen, (120, 120, 150), castle_rect, width=1)

        self.draw_castle_hp(self.screen, self.font)
        self.draw_wave_button(self.screen, self.font, self.wave_number)

        for enemy in self.enemies:
            enemy.draw(self.screen)

        pygame.display.flip()

    # ---------- DRAW HELPERS ----------
    @staticmethod
    def draw_background(screen):
        bottom_height = int(HEIGHT * BOTTOM_FRACTION)
        top_height = HEIGHT - bottom_height

        pygame.draw.rect(screen, (80, 80, 80), pygame.Rect(0, 0, WIDTH, top_height))
        pygame.draw.rect(
            screen,
            (50, 50, 50),
            pygame.Rect(0, top_height, WIDTH, bottom_height),
        )

    def draw_spawn_area(self, screen):
        rect = self.get_spawn_rect()
        pygame.draw.rect(screen, (100, 60, 60), rect)

    def draw_wave_button(self, screen, font, wave_number):
        rect = self.get_wave_button_rect()
        pygame.draw.rect(screen, (100, 100, 130), rect)
        pygame.draw.rect(screen, (0, 0, 0), rect, width=2)

        label = f"Next wave ({wave_number + 1}) - SPACE"
        text_surf = font.render(label, True, (255, 255, 255))
        text_rect = text_surf.get_rect(center=rect.center)
        screen.blit(text_surf, text_rect)

    def draw_castle_hp(self, screen, font):
        castle_rect = self.get_castle_rect()

        bar_width = 300
        bar_height = 20
        x = 20
        y = castle_rect.top + 20

        # background
        outline_rect = pygame.Rect(x, y, bar_width, bar_height)
        pygame.draw.rect(screen, (0, 0, 0), outline_rect, width=2)

        # fill hp part
        ratio = 0 if self.castle_max_hp == 0 else self.castle_hp / self.castle_max_hp
        fill_width = int(bar_width * ratio)
        fill_rect = pygame.Rect(x + 1, y + 1, max(0, fill_width - 2), bar_height - 2)

        # color
        r = int(200 * (1 - ratio))
        g = int(200 * ratio)
        color = (r, g, 0)
        pygame.draw.rect(screen, color, fill_rect)

        # text
        hp_text = f"Castle:HO {int(self.castle_hp)}/{int(self.castle_max_hp)}"
        text_surf = font.render(hp_text, True, (255, 255, 255))
        text_rect = text_surf.get_rect(midleft=(x, y - 8))
        screen.blit(text_surf, text_rect)

    @staticmethod
    def draw_slots(screen, font, labels):
        width, height = screen.get_size()
        bottom_height = int(height * BOTTOM_FRACTION)
        top_height = height - bottom_height

        hud_y = top_height
        hud_height = bottom_height

        num_slots = len(labels)

        slot_width = 100
        slot_height = 100
        margin_x = 40

        if num_slots > 1:
            spacing = (width - 2 * margin_x - num_slots * slot_width) // (num_slots - 1)
        else:
            spacing = 0

        base_y = hud_y + (hud_height - slot_height) // 2
        y_offsets = [30, 15, 0, 15, 30]

        for i, label in enumerate(labels):
            x = margin_x + i * (slot_width + spacing)
            y = base_y + y_offsets[i % len(y_offsets)]

            rect = pygame.Rect(x, y, slot_width, slot_height)

            pygame.draw.rect(screen, (120, 120, 120), rect)
            pygame.draw.rect(screen, (0, 0, 0), rect, width=2)

            text_surf = font.render(label, True, (255, 255, 255))
            text_rect = text_surf.get_rect(center=rect.center)
            screen.blit(text_surf, text_rect)


# -----------------------------
# ENTRY POINT
# -----------------------------
if __name__ == "__main__":
    game = Game()
    game.run()
